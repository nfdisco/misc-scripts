#!/bin/sh

progname="$(basename "$0")"

usage () {
    cat <<EOF
Usage: $progname [OPTIONS] [--] [PATH [PATH...]]
Search the filesystem for various types of files.

Options (at least one is required):

 -h, --hidden     search for hidden files
 -s, --links      search for broken symbolic links
 -e, --empty      search for empty files or directories
 -g, --large      search for large files
 -b, --backup     search for backup files
 -l, --latex      search for LaTeX byproducts

Other options:
 -r, --recursive  walk the directory tree recursively
 -d, --delete     delete the files found
     --help       show this help and exit

$progname uses GNU find extensions.

EOF
}

error () {
    # print $1 to stderr
    printf "%s: %s\n" "$progname" "$1" 1>&2
}

confirm_yes_no () {
    # exit with status 0 if yes
    printf "%s" "$1 [y/n] "
    stty cbreak
    reply=$(dd if=/dev/tty bs=1 count=1 2>/dev/null)
    stty -cbreak
    printf "\n"
    test "$reply" = "y" -o "$reply" = "Y"
}

links () {
    # search $1 for broken links, with options $2, do action $3
    find "$1" $2 -depth -xdev \
	-type l -! -execdir test -e "{}" \; $3
}

backups () {
    # search $1 for backup files, with options $2, do action $3
    find "$1" $2 -depth -xdev -type f \( \
	-name "*~" -o \
	-name "*?.bak" -o \
	-name "#*#" -o \
	-name "*?.sw[nop]" \) $3
}

dot_files () {
    # search $1 for hidden files, with options $2, do action $3
    find "$1" $2 -depth -xdev \( -type f -o -type d \) \
	-name ".*" -! -name "." -! -name ".." $3
}

empty () {
    # search $1 for empty files, with options $2, do action $3
    find "$1" $2 -depth -xdev \( -type f -o -type d \) -empty $3
}

large () {
    # search $1 for large files, with options $2, do action $3
    find "$1" $2 -depth -xdev -type f -size +100M $3
}

latex () {
    # search $1 for latex auxiliary files, with options $2, do action $3
    find "$1" $2 -depth -xdev -type f \
	\( -name "*?.aux" -o -name "*?.log" -o -name "*?.out" \) \
	-execdir sh -c \
	'u="{}"; v="${u%????}"; test -e "${v}.tex" -o -e "${v}.ltx"' \; $3
}

print_or_delete () {
    # perform action $1 on path $2, optionally recursively $3
    if "$@" -ls | grep ^ && [ -n "$delete" ]; then
	confirm_yes_no "delete?" && "$@" -delete
    fi
}

# command line arguments
getopt -T 2> /dev/null
if [ $? -ne 4 ]; then
    error "unsupported version of getopt"
    exit 1
fi

opts=rdhsegbl
long_opts=recursive,delete,hidden,links,empty,large,backup,latex,help

args="$(LC_ALL=C getopt -n "$progname" -s sh -o $opts -l $long_opts -- "$@")"
if [ $? -eq 0 ]; then
    eval set -- "$args"
else
    exit 1
fi

delete=
recursive=
targets=
while [ $# -gt 0 ]; do
    case "$1" in
	--help)
	    usage; exit 0 ;;
	-r|--recursive)
	    recursive=1 ;;
	-d|--delete)
	    delete=1 ;;
	-h|--hidden)
	    targets="$targets dot_files" ;;
	-s|--links)
	    targets="$targets links" ;;
	-e|--empty)
	    targets="$targets empty" ;;
	-g|--large)
	    targets="$targets large" ;;
	-b|--backup)
	    targets="$targets backups" ;;
	-l|--latex)
	    targets="$targets latex" ;;
	--)
	    shift; break ;;
	*)
	    break
    esac
    shift
done

if [ -z "$targets" ]; then
    error "option required"
    exit 1
fi

if [ $# -lt 1 ]; then
    error "too few arguments"
    exit 1
fi

opts=
if [ -z "$recursive" ]; then
    opts="-maxdepth 1"
fi

# main loop
for path in "$@"; do
    for target in $targets; do
	print_or_delete $target "$path" "$opts"
    done
done

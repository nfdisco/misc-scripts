#!/bin/sh
# Make backups using find and tar.

LC_ALL=C

usage () {
    # write help message to stdout
    cat <<EOF
usage: $0 OPTIONS [--] [OPERAND ...]
Make backups using find and tar.

Options:

 -i PATH              input directory
 -o PATH              output directory
 -r FILE              alternate config file
 -x                   do not read any config file
 -n NAME              backup name
          --help      show this help and exit

All arguments after "--"  are passed unchanged to find(1).

$0 uses GNU find extensions.

EOF
}

error () {			# $1=message
    # write message to stderr
    printf "$0: $1\n" 1>&2
}

parse_command_line_args () {	# $1=getopt string with quoted args
    # set variables from options, set rest_args to remaining args
    eval set -- "$1"
    while [ $# -gt 0 ]; do
	case "$1" in
	    --)
		shift; break ;;
	    --help)
		usage; return 1 ;;
	    -x)
		x=true ;;
	    -i|-o|-r|-n)
		eval "${1#-}=\"\${2}\""
		shift ;;
	    *)
		error "invalid parameter -- '${1#-}'"
		return 2
	esac
	shift
    done
    test $# -gt 0 && rest_args="$(getopt -s sh -o '' -- "$@")"
}

parse_rcfile_args () {		# $1=getopt string
    # set variables from options, set rest_args to remaining args
    eval set -- "$1"
    shift			# the first arg is -- generated by getopt
    while [ $# -gt 0 ]; do
	case "${1%%=*}" in
	    --)
		shift; break ;;
	    i|o)
		eval "${1%%=*}=\"\${1#*=}\"" ;;
	    *)
		error "invalid parameter in config file -- '${1%%=*}'"
		return 1
	esac
	shift
    done
    test $# -gt 0 && rest_args="$(getopt -s sh -o '' -- "$@")"
}

get_rcfile_section () (		# $1=filename $2=section
    # write section to stdout
    cat "$1" | grep -v '^[[:space:]]*$\|^[[:space:]]*#.*' \
	| while IFS= read line;
    do
	if [ -z "${line##[[]*[]]}" ]; then
	    if [ "$line" = "[$2]" ]; then
		insection=true
	    else
		insection=
	    fi
	elif [ -n "$insection" ]; then
	    printf '%s\n' "$line"
	fi
    done
)

human_readable () (	# $1=amount in bytes
    # write string to stdout
    if [ $1 -lt 1024 ]; then
	printf '%dB\n' $1
    else
	KB=1024
	MB=$(($KB*1024))
	GB=$(($MB*1024))
	TB=$(($GB*1024))
	for unit in TB GB MB KB; do
	    eval "base=\$$unit"
	    if [ $1 -ge $base ]; then
		x=$((($1*10) / $base))
		break
	    fi
	done
	printf '%d.%d%s\n' $((x/10)) $((x%10)) $unit
    fi
)

ask () {			# $1=question $2=options
    # set REPLY
    # options: x=..|y=..
    while $(true); do
    	printf '%s [%s] ' "$1" "$2"
	stty cbreak
	REPLY=$(dd if=/dev/tty bs=1 count=1 2> /dev/null)
	stty -cbreak
	test "$REPLY" != "$(printf '\n')" && printf '\n'
	(
	    IFS='|'
	    for o in $2; do
		if [ "$REPLY" = "${o%%=*}" ]; then
		    printf '\n'
		    break
		fi
	    done
	) | grep ^ > /dev/null && return
    done
}

free_space () (		    # $1=file
    # write free disk space in bytes to stdout
    printf '%d\n' \
	$((1024 * $(df -k -P "$1" | tail -n 1 | tr -s ' ' '\t' | cut -f 4)))
)

temporary_file () {
    # make temp file, write filename to stdout
    mktemp || \
	{ error "could not create temporary file"; cleanup; return 1; }
}

find_previous_backup () (	# $1=basename $2=path
    # write filename to stdout
    # pattern: <NAME>.<NUMBER>.TAR.*
    cd "$2" || { cleanup; return 1; }
    ls -t -r | grep "^$1\.[0-9][0-9]*\.tar" | tail -n 1
)

current_backup () {		# $1=basename [$2=previous]
    # write filename to stdout
    if [ -n "$2" ]; then
	num=$(printf '%s\n' "$(basename "$2")" | \
	    sed "s/^$1\.\([0-9][0-9]*\)\.tar.*/\1/")
    else
	num=-1
    fi
    printf '%s.%04d.tar\n' "$1" $((1+$num))
}

cleanup () {
    test -n "$files" && rm -f "$files"
    test -n "$sizes" && rm -f "$sizes"
}

run_find () {			# $1=path $2=reference [args...]
    # set files and sizes
    files="$(temporary_file)" || return $?
    sizes="$(temporary_file)" || return $?
    (
	path="$1"
	reference="${2:+-newer "$2"}"
	shift 2
	find "$path" -xdev -depth ${reference} "$@" \
	    -fprint0 "$files" -printf '%s\n' > "$sizes"
    )
}

sum () (			# [$1=file]
    # write total to stdout
    while read number; do
	total=$(($total+$number))
    done
    printf "%d\n" ${total:-0}
)

# parse command line

i=
o=
r="$HOME/.config/backuprc"
x=
n=
rest_args=
opts="i:o:r:xn:"
longopts="help"

cl_args="$(getopt -n "$0" -s sh -o $opts -l $longopts -- "$@")"

parse_command_line_args "$cl_args" || exit $(($?-1))
test -z "$n" && { error "required argument missing -- 'n'"; exit 1; }

if [ -z "$x" ]; then
    rc_args="$(get_rcfile_section "$r" "$n" | xargs getopt -s sh -o '' --)"
    parse_rcfile_args "$rc_args" || exit $?
    find_expr="$rest_args"
fi

# parse command line again in order to override parameters from rcfile
parse_command_line_args "$cl_args" || exit $(($?-1))
find_expr="$find_args $rest_args"

# set positional arguments
eval set -- $find_expr

# printf "i='%s'\n" "$i"		# input directory
# printf "o='%s'\n" "$o"		# output directory
# printf "r='%s'\n" "$r"		# rcfile
# printf "x='%s'\n" "$x"		# 
# printf "n='%s'\n" "$n"		# name
# printf "positional arguments\n"
# printf "%s\n" "$@"		# find arguments expressions

test -z "$i" && { error "required argument missing -- 'i'"; exit 1; }
test -z "$o" && { error "required argument missing -- 'o'"; exit 1; }
test -d "$i" || { error "no such directory -- '$i'"; exit 1; }
test -d "$o" || { error "no such directory -- '$o'"; exit 1; }

o="$(dirname "$o")/$(basename "$o")"
previous_backup="$(find_previous_backup "$n" "$o")" || exit $?
previous_backup="${previous_backup:+$o/$previous_backup}"
output_file="$o/$(current_backup "$n" "$previous_backup").gz"

test -n "$previous_backup" && previous=true
test -e "$output_file" && overwrite=true

run_find "$i" "$previous_backup" "$@" || exit $?
if ! [ $? -eq 0 ]; then
    error "find exited with non-zero status"
    cleanup
    exit 1
fi

file_count=$(wc -l < "$sizes")
if [ $file_count -eq 0 ]; then
    printf "nothing to back up\n"
    cleanup
    exit 0
fi

backup_size=$(sum < "$sizes")

if [ -n "$previous_backup" ]; then
    printf "previous backup found\n"
else
    printf "no previous backup found\n"
fi
printf '%d file(s) (%s) will be backed up\n' \
    $file_count $(human_readable $backup_size)
printf "output file is: '%s'\n" "$(basename $output_file)"
if [ -n "$overwrite" ]; then
    printf "output file exists -- will be OVERWRITTEN!\n"
fi
printf "output directory is: '%s'\n" "$(dirname "$output_file")"
printf "%s available in output directory\n" \
    $(human_readable $(free_space $(dirname "$output_file")))

REPLY=
printf '\n'
while [ "$REPLY" != "y" ]; do
    ask 'proceed?' 'y=yes|n=no|v=view files'
    case "$REPLY" in
	v) tr '\0' '\n' < "$files" | less ;;
	n) cleanup; exit 0
    esac
done

# run_tar
tar --file "$output_file" --null --files-from "$files" --create \
    --no-recursion --preserve-permissions --totals --gzip
if [ $? -ne 0 ]; then
    printf "tar exited with non-zero status.\n"
fi
cleanup
printf "bye.\n"

#!/bin/sh
# 
# TODO: check that value of otherchars is valid in bracket expression.

progname="$(basename "$0")"

usage () {
    # show help
    cat <<EOF
usage: $progname [OPTIONS] [--] [FILE [FILE...]]
Rename files using Unix-friendly filenames.

Options:
 -d  --dots=N         number of dots allowed (default: 1)
 -o  --other=CHARS    other characters allowed in filenames
     --dry            dry run; do not rename
     --help           show this help and exit

By default the only characters allowed in filenames are alphanumeric
characters, hyphens and the first dot counting from the right.  A
leading dot is always allowed and does not count as dot as far as
option -d is concerned.

EOF
}

error () {
    # write $1 to stderr
    printf -- "$progname: %s\n" "$1" 1>&2
}

# command line arguments
getopt -T 2> /dev/null
if [ $? -ne 4 ]; then
    error "unsupported version of getopt"
    exit 1
fi

short_opts=d:o:
long_opts=dots:,other:,dry,help

args="$(LC_ALL=C getopt -n "$progname" -s sh -o $short_opts -l $long_opts -- "$@")"
if [ $? -eq 0 ]; then
    eval set -- "$args"
else
    exit 1
fi

rightdots=1
otherchars=
mv="mv"
while [ $# -gt 0 ]; do
    case "$1" in
	--help)
	    usage; exit 0 ;;
	-d|--dots)
	    rightdots="$2"; shift
	    if [ "$rightdots" -ne "$rightdots" ] 2> /dev/null; then
		error "option -d requires integer argument -- '$1'"
		exit 1
	    fi ;;
	-o|--other)
	    otherchars="$2"; shift ;;
	--dry)
	    mv="echo mv" ;;
	--)
	    shift; break ;;
	*)
	    break
    esac
    shift
done

# check required args
if [ $# -lt 1 ]; then
    error "must specify at least one non-option argument"
    exit 1
fi

# awk program - somewhat simpler that using shell commands
unixfy='
BEGIN {
    FS="[.]"
}
1 {
    if (match($0, /.*[/]/)) {
	dirpart = substr($0, 1, RLENGTH)
	$0 = substr($0, RLENGTH+1)
    } else {
	dirpart = ""
    }
    if ($1 == "")
	leftdots = 1
    if (rightdots > -1) {
	while(NF > (rightdots+1))
	    sub(/[.]/, ",")
    }
    gsub("[^[:alnum:]." otherchars "]+", "-")
    if (leftdots) {
	$0 = "." substr($0,2)
	leftdots = 0
    }
    do {
	if (match($0, /[^.]-([.]|$)/) || match($0, /[.]-[^.]/))
	    $0 = substr($0,1,RSTART) substr($0,RSTART+2)
    } while (RSTART)
    if (match($0, /^-[^.]/))
	$0 = substr($0,2)
    printf "%s%s\n", dirpart, tolower($0)
}
'

# printf "otherchars=$otherchars\n"
# printf "rightdots=$rightdots\n"
# printf "mv=$mv\n"
# printf "%s\n" "$@"

# main loop
printf "%s\000" "$@" | \
    awk -v RS="\000" \
	-v otherchars="$otherchars" \
	-v rightdots=$rightdots \
	"$unixfy" | \
    while read dest; do
	if [ "$1" != "$dest" ]; then
	    $mv -i "$1" "$dest"
	fi
	shift
    done



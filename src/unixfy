#!/bin/sh

replace_chars="_ .,;-"
# delete_chars="()[]{}*?!^~%\\\<>&\$#|'\`\""

usage () {
    # show help
    cat <<EOF
usage: $0 [OPTIONS] [--] [FILE [FILE...]]
Rename files using Unix-friendly filenames.

Options:
 -e N              number of extensions or, if N < 0, do not
                   replace dots from filenames (default: N=1)
 -d    --dry       dry run; do not rename
       --help      show this help and exit

Single and multiple occurrences of the following characters are
replaced with a single hyphen: $replace_chars

Dots are handled in a particular way because they usually have a
special meaning.  By default, the last dot in a filename is not
replaced, as it is assumed to be an extension marker.  A leading dot
in a filename is never replaced either.

In addition to replacing, non-alphanumeric characters are removed.
The exact definition of alphanumeric depends on the locale in use.
Finally, the filename is converted to lower case.

EOF
}

error () {
    # write $1 to stderr
    printf "%s\n" "$1" 1>&2
}

split () (
    # split filename ($1) into base and n ($2) extensions using slash
    # as separator; a leading dot always counts as extension separator
    # 
    # examples:
    # split '.x.x.x.x'  0 -> '/x.x.x.x.x
    # split '.x.x.x.x'  1 -> '/x.x.x.x/x
    # split '.x.x.x.x'  2 -> '/x.x.x/x/x
    # split '.x.x.x.x' -1 -> '/x/x/x/x/x
    nf=$(printf '%s\n' "$1" | tr -d -C . | wc -c)
    if [ $2 -lt 0 ]; then
	keep=0
    else
	keep=$((nf-$2))
    fi
    IFS=. i=0 out= sep=
    for part in $1; do
	out="$out$sep$part"
	if [ -z "$out" -o $i -ge $keep ]; then
	    sep=/
	else
	    sep=.
	fi
	i=$(($i+1))
    done
    printf '%s\n' "$out"
)

normalize_string () (
    # normalize $1 by replacing unwanted characters, removing
    # non-alphanumeric characters and converting to lower case; some
    # minor cosmetic changes are also performed
    printf '%s\n' "$1" \
	| tr -s "$replace_chars" - \
	| sed 's/[^[:alnum:]-]//g; s/^-\(.\)/\1/; s/\(.\)-$/\1/; s/.*/\L&/'
)

normalize_filename () (
    # normalize $1, where $1 is a filename with $2 extensions, by
    # normalizing every component of the filename, in turn
    IFS=/ out= sep=
    for part in $(split "$1" "$2"); do
	out="$out$sep$(normalize_string "$part")"
	sep=.
    done
    printf '%s\n' "$out"
)

rename () (
    # rename file $1 by giving it a normalized filename; keep $2
    # filename extensions; if $3 is not null do a dry run
    dir="$(dirname -- "$1")"
    old="$(basename -- "$1")"
    new="$(normalize_filename "$old" "$2")"
    if [ "$new" != "$old" ]; then
	${3:+echo} mv -i -- "$dir/$old" "$dir/$new"
    fi
)

# command line arguments
getopt -T 2> /dev/null
if [ $? -ne 4 ]; then
    error "unsupported version of getopt"
    exit 1
fi

short_opts=e:d
long_opts=help,dry

args="$(LC_ALL=C getopt -n "$0" -s sh -o $short_opts -l $long_opts -- "$@")"
if [ $? -eq 0 ]; then
    eval set -- "$args"
else
    exit 1
fi

e=
dry=
while [ $# -gt 0 ]; do
    case "$1" in
	--help)
	    usage; exit 0 ;;
	-p)
	    e="$2"; shift
	    if [ "$e" -ne "$e" ] 2> /dev/null; then
		error "$0: option requires integer argument -- 'e'"
		exit 1
	    fi ;;
	-d|--dry)
	    dry=1 ;;
	--)
	    shift; break ;;
	*)
	    break
    esac
    shift
done

# defaults args
e=${e:-1}

# check required args
if [ $# -lt 1 ]; then
    error "$0: required non-option argument missing"
    exit 1
fi

# main loop
for file in "$@"; do
    rename "$file" "$e" "$dry"
done
